# whatsappcrm_backend/football_data_app/utils.py

import re
import logging
from django.db.models import Q
from django.apps import apps
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal
from typing import Optional, Dict, List, Any, Union
from football_data_app.models import *
# Lazy imports for models. Using `FootballFixture` as the main fixture model name.



logger = logging.getLogger(__name__)

def get_formatted_football_data(
    data_type: str, 
    league_code: Optional[str] = None, 
    days_ahead: int = 10, 
    days_past: int = 2
) -> List[str]:
    """
    Fetches and formats football data for display in a single, attractive message.
    Output includes: League, Fixture ID, Date/Time, Teams, and simplified odds/results.
    Displays up to 10 fixtures. Includes emojis and a "Generated by BetBlitz" footer.
    
    This function now returns a list of strings, where each string is a message part
    designed to be under WhatsApp's character limit.
    
    This function interacts with the FootballFixture, Market, MarketOutcome, League, and Team models.
    """
    logger.info(f"Function Call: get_formatted_football_data(data_type='{data_type}', league_code='{league_code}', days_ahead={days_ahead}, days_past={days_past})")

    MAX_CHARS_PER_PART = 4000  # Stay under WhatsApp's 4096 char limit
    PART_JOINER = "\n\n---\n"  # Separator for items within a single message part

    now = timezone.now()
    # Prepare footer string once
    now_harare = timezone.localtime(now)
    datetime_str = now_harare.strftime('%B %d, %Y, %I:%M %p %Z')
    footer_string = f"\n\n_Generated by BetBlitz on {datetime_str}_"

    if data_type == "scheduled_fixtures":
        data_type_label = "Upcoming Matches"
        main_header = f"⚽ *{data_type_label}*"
        start_date = now
        end_date = now + timedelta(days=days_ahead)
        
        logger.debug(f"Querying for SCHEDULED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter( 
            status=FootballFixture.FixtureStatus.SCHEDULED, 
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').prefetch_related(
            'markets__outcomes'
        ).order_by('match_date')

        if league_code:
            logger.debug(f"Filtering scheduled fixtures by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)

        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            no_data_message = f"No {data_type_label.lower()} found{league_info} at this time."
            return [no_data_message + footer_string]

        num_fixtures_to_display = 20
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_fixtures_to_display)} scheduled fixtures.")
        
        # This list will hold the formatted string for each individual fixture
        individual_item_strings: List[str] = []
        
        for fixture in fixtures_qs[:num_fixtures_to_display]: 
            match_time_local = timezone.localtime(fixture.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p') 
            
            # Build the multi-line string for a single fixture
            line = f"\n🏆 *{fixture.league.name}* (ID: {fixture.id})" 
            line += f"\n🗓️ {time_str}" 
            line += f"\n{fixture.home_team.name} vs {fixture.away_team.name}"
            
            aggregated_outcomes: Dict[str, Dict[str, MarketOutcome]] = {} 
            
            # Iterate through markets related to this fixture
            for market in fixture.markets.all():
                market_key = market.api_market_key # Accessing api_market_key from Market
                if market_key not in aggregated_outcomes:
                    aggregated_outcomes[market_key] = {}

                # Iterate through outcomes related to this market
                for outcome in market.outcomes.all():
                    # outcome_name and point_value are from MarketOutcome model
                    outcome_identifier = f"{outcome.outcome_name}-{outcome.point_value if outcome.point_value is not None else ''}"
                    
                    current_best_outcome = aggregated_outcomes[market_key].get(outcome_identifier)
                    # For a given outcome_identifier, take the one with the best odds (highest)
                    if current_best_outcome is None or outcome.odds > current_best_outcome.odds:
                        aggregated_outcomes[market_key][outcome_identifier] = outcome
            
            compact_odds_parts: List[str] = []

            # Format Head-to-Head (h2h) odds
            if 'h2h' in aggregated_outcomes:
                home_odds = aggregated_outcomes['h2h'].get(f"{fixture.home_team.name}-")
                draw_odds = aggregated_outcomes['h2h'].get('Draw-')
                away_odds = aggregated_outcomes['h2h'].get(f"{fixture.away_team.name}-")
                
                if home_odds: compact_odds_parts.append(f"🏠Home:*{home_odds.odds:.2f}*") 
                if draw_odds: compact_odds_parts.append(f"🤝Draw:*{draw_odds.odds:.2f}*")
                if away_odds: compact_odds_parts.append(f"✈️Away:*{away_odds.odds:.2f}*")

            # Format Totals (Over/Under) odds
            if 'totals' in aggregated_outcomes:
                best_overall_over = None; best_overall_under = None
                for outcome_obj in aggregated_outcomes['totals'].values():
                    if 'over' in outcome_obj.outcome_name.lower(): # Accessing outcome_name from MarketOutcome
                        if best_overall_over is None or outcome_obj.odds > best_overall_over.odds: best_overall_over = outcome_obj
                    elif 'under' in outcome_obj.outcome_name.lower(): # Accessing outcome_name from MarketOutcome
                        if best_overall_under is None or outcome_obj.odds > best_overall_under.odds: best_overall_under = outcome_obj
                
                if best_overall_over:
                    # Accessing point_value from MarketOutcome
                    over_point_str = f"{best_overall_over.point_value:.1f}" if best_overall_over.point_value is not None else ""
                    compact_odds_parts.append(f"⬆️Over{over_point_str}:*{best_overall_over.odds:.2f}*") 
                if best_overall_under:
                    # Accessing point_value from MarketOutcome
                    under_point_str = f"{best_overall_under.point_value:.1f}" if best_overall_under.point_value is not None else ""
                    compact_odds_parts.append(f"⬇️Under{under_point_str}:*{best_overall_under.odds:.2f}*")

            # Format Both Teams to Score (btts) odds
            if 'btts' in aggregated_outcomes:
                yes_odds = aggregated_outcomes['btts'].get('Yes-') 
                no_odds = aggregated_outcomes['btts'].get('No-') 
                if yes_odds: compact_odds_parts.append(f"✅BTTS Y:*{yes_odds.odds:.2f}*")
                if no_odds: compact_odds_parts.append(f"❌BTTS N:*{no_odds.odds:.2f}*")
            
            # Format Spreads odds
            if 'spreads' in aggregated_outcomes:
                best_home_spread = None; best_away_spread = None
                for outcome_obj in aggregated_outcomes['spreads'].values():
                    if outcome_obj.outcome_name == fixture.home_team.name: # Accessing outcome_name from MarketOutcome
                        if best_home_spread is None or outcome_obj.odds > best_home_spread.odds: best_home_spread = outcome_obj
                    elif outcome_obj.outcome_name == fixture.away_team.name: # Accessing outcome_name from MarketOutcome
                        if best_away_spread is None or outcome_obj.odds > best_away_spread.odds: best_away_spread = outcome_obj
                
                if best_home_spread:
                    # Accessing point_value from MarketOutcome
                    home_spread_point_str = f"{best_home_spread.point_value:.1f}" if best_home_spread.point_value is not None else ""
                    compact_odds_parts.append(f"📊 S {fixture.home_team.name}({home_spread_point_str}):*{best_home_spread.odds:.2f}*") 
                if best_away_spread:
                    # Accessing point_value from MarketOutcome
                    away_spread_point_str = f"({best_away_spread.point_value:.1f})" if best_away_spread.point_value is not None else ""
                    compact_odds_parts.append(f"📊 S {fixture.away_team.name}{away_spread_point_str}:*{best_away_spread.odds:.2f}*") 
            
            if compact_odds_parts:
                line += "\nOdds: " + " | ".join(compact_odds_parts)
            else:
                line += "\n_No odds available_" 
            individual_item_strings.append(line.strip()) # Add the fully formatted fixture string
        
    elif data_type == "finished_results":
        data_type_label = "Recent Results"
        main_header = "⚽ *Recent Results*"
        end_date = now
        start_date = now - timedelta(days=days_past)
        
        logger.debug(f"Querying for FINISHED fixtures between {start_date} and {end_date}.")
        # status, match_date fields assumed to exist on FootballFixture model. FixtureStatus assumed to exist on FootballFixture.
        fixtures_qs = FootballFixture.objects.filter( 
            status=FootballFixture.FixtureStatus.FINISHED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').order_by('-match_date')
        
        if league_code:
            logger.debug(f"Filtering finished results by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)
        
        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            no_data_message = f"No {data_type_label.lower()} found{league_info} at this time."
            return [no_data_message + footer_string]
        
        num_fixtures_to_display = 10 
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_fixtures_to_display)} finished matches.")
        
        individual_item_strings: List[str] = []

        for fixture in fixtures_qs[:num_fixtures_to_display]: 
            match_time_local = timezone.localtime(fixture.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p') 
            
            line = f"\n🏆 *{fixture.league.name}* (ID: {fixture.id})" 
            line += f"\n🗓️ {time_str}" 
            line += f"\n{fixture.home_team.name} vs {fixture.away_team.name}"
            
            # home_team_score and away_team_score are assumed to exist on FootballFixture model.
            if fixture.home_team_score is not None:
                line += f" | Result: *{fixture.home_team_score} - {fixture.away_team_score}*" 
            
            individual_item_strings.append(line.strip()) # Add the fully formatted result string

    else:
        logger.warning(f"Invalid data type requested: '{data_type}'. Returning error message.")
        return ["Invalid data type requested. Please check your input." + footer_string]

    if not individual_item_strings:
        # This case should ideally be covered by `fixtures_qs.exists()` check earlier
        logger.info(f"No items to format for {data_type_label}.")
        no_data_message = f"No {data_type_label.lower()} found at this time."
        return [no_data_message + footer_string]

    # Assemble message parts
    all_message_parts: List[str] = []
    current_part_items: List[str] = []
    current_part_length = 0
    
    # Header is added to the first part only. Account for its length.
    # The actual header string is prepended when the first part is finalized.
    header_allowance = len(main_header) + len("\n\n") # Header + blank line separator

    for i, item_str in enumerate(individual_item_strings):
        separator_len = len(PART_JOINER) if current_part_items else 0
        
        # Calculate prospective length if this item is added to the current part
        prospective_item_len = separator_len + len(item_str)
        current_total_prospective_len = current_part_length + prospective_item_len
        
        # If this is the very first part being built, add header allowance
        if not all_message_parts:
            current_total_prospective_len += header_allowance

        if current_total_prospective_len > MAX_CHARS_PER_PART and current_part_items:
            # Finalize the current part
            part_to_add = PART_JOINER.join(current_part_items)
            if not all_message_parts: # This was the first part, prepend header
                part_to_add = main_header + "\n\n" + part_to_add
            all_message_parts.append(part_to_add)
            
            # Start new part with current item
            current_part_items = [item_str]
            current_part_length = len(item_str)
        else:
            # Add item to current part
            current_part_items.append(item_str)
            current_part_length += prospective_item_len

    # Add any remaining content as the last part
    if current_part_items:
        final_part_str = PART_JOINER.join(current_part_items)
        if not all_message_parts: # This is the very first and only part
            final_part_str = main_header + "\n\n" + final_part_str
        all_message_parts.append(final_part_str)

    # Add footer to the last message part
    if all_message_parts:
        if len(all_message_parts[-1]) + len(footer_string) <= MAX_CHARS_PER_PART:
            all_message_parts[-1] += footer_string
        else:
            all_message_parts.append(footer_string) # Footer as a new message if it doesn't fit
    
    logger.info(f"Formatted data for data_type='{data_type}' into {len(all_message_parts)} parts.")
    return all_message_parts


def parse_betting_string(betting_string: str) -> dict:
    """
    Parses a free-form betting string into a list of market outcome IDs and a stake,
    where each bet line specifies a fixture ID (Django's auto-incrementing PK) and an outcome option.

    Expected format for each bet line: "FIXTURE_ID_INTEGER OPTION_TEXT"
    Example: "6373 Away win"
    Expected format for stake: "Stake $AMOUNT" or "Stake AMOUNT"
    Example: "Stake $5"

    Args:
        betting_string (str): The raw text input from the user.

    Returns:
        dict: A dictionary containing success status, message, list of market_outcome_ids,
              and the stake amount.
    """
    lines = [line.strip() for line in betting_string.split('\n') if line.strip()]
    market_outcome_ids = []
    stake_amount = Decimal('0.0')

    stake_pattern = re.compile(r"Stake\s*\$?\s*([\d\.,]+)", re.IGNORECASE)
    bet_line_pattern = re.compile(r"(\d+)\s+(.*)", re.IGNORECASE)

    for line in lines:
        stake_match = stake_pattern.match(line)
        if stake_match:
            try:
                stake_str = stake_match.group(1).replace(',', '')
                stake_amount = Decimal(stake_str)
            except ValueError:
                return {"success": False, "message": f"Invalid stake amount: {stake_match.group(1)}"}
            continue

        bet_line_match = bet_line_pattern.match(line)
        if bet_line_match:
            fixture_id_str = bet_line_match.group(1).strip()
            option_text = bet_line_match.group(2).strip()

            try:
                matched_fixture = None
                try:
                    # Attempt to get FootballFixture by its integer primary key (id)
                    matched_fixture = FootballFixture.objects.get(id=int(fixture_id_str))
                except (ValueError, FootballFixture.DoesNotExist):
                    pass

                if not matched_fixture:
                    return {"success": False, "message": f"Could not find a fixture for ID '{fixture_id_str}'."}

                found_outcome = None
                
                # Filter MarketOutcomes that belong to markets associated with the matched_fixture
                # Relies on `market__fixture_display` as per your original `Market` model
                outcomes_for_fixture = MarketOutcome.objects.filter(
                    market__fixture_display=matched_fixture, # Corrected: use market__fixture_display
                    is_active=True
                ).select_related('market')

                # Logic to robustly match 'option_text' to `MarketOutcome.outcome_name`
                # Relies on `outcome_name` and `point_value` fields on MarketOutcome.
                # Relies on `category.name` and `api_market_key` fields on Market.
                
                # Try exact outcome_name match first
                for outcome in outcomes_for_fixture:
                    if outcome.outcome_name.lower() == option_text.lower():
                        found_outcome = outcome
                        break
                
                if not found_outcome:
                    # Generic 'win', 'draw' for match winner markets
                    if "win" in option_text.lower() or "draw" in option_text.lower():
                        for outcome in outcomes_for_fixture:
                            if "match winner" in outcome.market.category.name.lower() and \
                               (option_text.lower() == "home win" and "home win" in outcome.outcome_name.lower() or \
                                option_text.lower() == "away win" and "away win" in outcome.outcome_name.lower() or \
                                option_text.lower() == "draw" and "draw" in outcome.outcome_name.lower()):
                                found_outcome = outcome
                                break
                    
                    # For "Both teams to Score"
                    if not found_outcome and "both teams to score" in option_text.lower():
                        for outcome in outcomes_for_fixture:
                            if "both teams to score" in outcome.market.category.name.lower():
                                if ("yes" in option_text.lower() and "yes" in outcome.outcome_name.lower()) or \
                                   ("no" in option_text.lower() and "no" in outcome.outcome_name.lower()):
                                    found_outcome = outcome
                                    break
                    
                    # For "Home Win or Draw" (double chance)
                    if not found_outcome and ("home win or draw" in option_text.lower() or "1x" in option_text.lower()):
                         for outcome in outcomes_for_fixture:
                            if "double chance" in outcome.market.category.name.lower() and \
                               ("1x" in outcome.outcome_name.lower() or "home/draw" in outcome.outcome_name.lower()):
                                found_outcome = outcome
                                break
                    # More double chance examples
                    if not found_outcome and ("away win or draw" in option_text.lower() or "x2" in option_text.lower()):
                         for outcome in outcomes_for_fixture:
                            if "double chance" in outcome.market.category.name.lower() and \
                               ("x2" in outcome.outcome_name.lower() or "away/draw" in outcome.outcome_name.lower()):
                                found_outcome = outcome
                                break
                    if not found_outcome and ("home or away win" in option_text.lower() or "12" in option_text.lower()):
                         for outcome in outcomes_for_fixture:
                            if "double chance" in outcome.market.category.name.lower() and \
                               ("12" in outcome.outcome_name.lower() or "home/away" in outcome.outcome_name.lower()):
                                found_outcome = outcome
                                break

                    # For "Over X,Y" and "Under X,Y" (total goals)
                    over_under_match = re.search(r"(over|under)\s*([\d\.]+)", option_text, re.IGNORECASE)
                    if not found_outcome and over_under_match:
                        type_str = over_under_match.group(1).lower()
                        value_str = over_under_match.group(2)
                        for outcome in outcomes_for_fixture:
                            if ("total goals" in outcome.market.category.name.lower() or \
                                "over/under" in outcome.market.category.name.lower()) and \
                                f"{type_str} {value_str}" in outcome.outcome_name.lower().replace(',', '.'):
                                found_outcome = outcome
                                break

                    # For player to score
                    if not found_outcome and "to score" in option_text.lower():
                        player_name = option_text.lower().replace("to score", "").strip()
                        for outcome in outcomes_for_fixture:
                            if "goalscorer" in outcome.market.category.name.lower() and \
                                player_name in outcome.outcome_name.lower():
                                found_outcome = outcome
                                break


                if found_outcome:
                    market_outcome_ids.append(str(found_outcome.uuid))
                else:
                    return {"success": False, "message": f"Could not find a valid betting option for '{option_text}' in fixture '{matched_fixture.home_team.name} vs {matched_fixture.away_team.name}' (ID: {matched_fixture.id})."}

            except Exception as e:
                import traceback
                traceback.print_exc()
                return {"success": False, "message": f"Error during bet option lookup for '{fixture_id_str} {option_text}': {str(e)}"}
        else:
            return {"success": False, "message": f"Unrecognized betting line format: '{line}'"}

    if not market_outcome_ids:
        return {"success": False, "message": "No valid betting options found in the message."}
    if stake_amount <= 0:
        return {"success": False, "message": "Stake amount not found or is invalid. Please specify 'Stake $AMOUNT'."}

    return {
        "success": True,
        "market_outcome_ids": market_outcome_ids,
        "stake": float(stake_amount),
        "message": "Betting string parsed successfully."
    }