# whatsappcrm_backend/football_data_app/utils.py

import re
import logging
from django.db.models import Q
from django.apps import apps
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal
from typing import Optional, Dict, List, Any, Union
from football_data_app.models import *

logger = logging.getLogger(__name__)

def get_formatted_football_data(
    data_type: str,
    league_code: Optional[str] = None,
    days_ahead: int = 10,
    days_past: int = 2
) -> Optional[List[str]]: # MODIFIED: Return type can now be None
    """
    Fetches and formats football data for display.
    This function now returns a list of strings (message parts) OR None if no data is found.
    """
    logger.info(f"Function Call: get_formatted_football_data(data_type='{data_type}', league_code='{league_code}', days_ahead={days_ahead}, days_past={days_past})")

    MAX_CHARS_PER_PART = 4000
    PART_JOINER = "\n\n---\n"

    now = timezone.now()
    now_harare = timezone.localtime(now)
    datetime_str = now_harare.strftime('%B %d, %Y, %I:%M %p %Z')
    footer_string = f"\n\n_Generated by BetBlitz on {datetime_str}_"

    individual_item_strings: List[str] = []
    main_header = ""
    data_type_label = ""

    if data_type == "scheduled_fixtures":
        data_type_label = "Upcoming Matches"
        main_header = f"‚öΩ *{data_type_label}*"
        start_date = now
        end_date = now + timedelta(days=days_ahead)

        logger.debug(f"Querying for SCHEDULED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.SCHEDULED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').prefetch_related(
            'markets__outcomes'
        ).order_by('match_date')

        if league_code:
            logger.debug(f"Filtering scheduled fixtures by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)

        # ---MODIFIED BEHAVIOR---
        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria. Returning None.")
            return None

        num_fixtures_to_display = 20
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_fixtures_to_display)} scheduled fixtures.")

        for fixture in fixtures_qs[:num_fixtures_to_display]:
            match_time_local = timezone.localtime(fixture.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p')

            line = f"\nüèÜ *{fixture.league.name}* (ID: {fixture.id})"
            line += f"\nüóìÔ∏è {time_str}"
            line += f"\n{fixture.home_team.name} vs {fixture.away_team.name}"

            aggregated_outcomes: Dict[str, Dict[str, MarketOutcome]] = {}
            for market in fixture.markets.all():
                market_key = market.api_market_key
                if market_key not in aggregated_outcomes:
                    aggregated_outcomes[market_key] = {}
                for outcome in market.outcomes.all():
                    outcome_identifier = f"{outcome.outcome_name}-{outcome.point_value if outcome.point_value is not None else ''}"
                    current_best_outcome = aggregated_outcomes[market_key].get(outcome_identifier)
                    if current_best_outcome is None or outcome.odds > current_best_outcome.odds:
                        aggregated_outcomes[market_key][outcome_identifier] = outcome

            compact_odds_parts: List[str] = []
            if 'h2h' in aggregated_outcomes:
                home_odds = aggregated_outcomes['h2h'].get(f"{fixture.home_team.name}-")
                draw_odds = aggregated_outcomes['h2h'].get('Draw-')
                away_odds = aggregated_outcomes['h2h'].get(f"{fixture.away_team.name}-")
                if home_odds: compact_odds_parts.append(f"üè†Home:*{home_odds.odds:.2f}*")
                if draw_odds: compact_odds_parts.append(f"ü§ùDraw:*{draw_odds.odds:.2f}*")
                if away_odds: compact_odds_parts.append(f"‚úàÔ∏èAway:*{away_odds.odds:.2f}*")

            if 'totals' in aggregated_outcomes:
                best_overall_over = None; best_overall_under = None
                for outcome_obj in aggregated_outcomes['totals'].values():
                    if 'over' in outcome_obj.outcome_name.lower():
                        if best_overall_over is None or outcome_obj.odds > best_overall_over.odds: best_overall_over = outcome_obj
                    elif 'under' in outcome_obj.outcome_name.lower():
                        if best_overall_under is None or outcome_obj.odds > best_overall_under.odds: best_overall_under = outcome_obj
                
                if best_overall_over:
                    over_point_str = f"{best_overall_over.point_value:.1f}" if best_overall_over.point_value is not None else ""
                    compact_odds_parts.append(f"‚¨ÜÔ∏èOver{over_point_str}:*{best_overall_over.odds:.2f}*")
                if best_overall_under:
                    under_point_str = f"{best_overall_under.point_value:.1f}" if best_overall_under.point_value is not None else ""
                    compact_odds_parts.append(f"‚¨áÔ∏èUnder{under_point_str}:*{best_overall_under.odds:.2f}*")

            if 'btts' in aggregated_outcomes:
                yes_odds = aggregated_outcomes['btts'].get('Yes-')
                no_odds = aggregated_outcomes['btts'].get('No-')
                if yes_odds: compact_odds_parts.append(f"‚úÖBTTS Y:*{yes_odds.odds:.2f}*")
                if no_odds: compact_odds_parts.append(f"‚ùåBTTS N:*{no_odds.odds:.2f}*")

            if 'spreads' in aggregated_outcomes:
                best_home_spread = None; best_away_spread = None
                for outcome_obj in aggregated_outcomes['spreads'].values():
                    if outcome_obj.outcome_name == fixture.home_team.name:
                        if best_home_spread is None or outcome_obj.odds > best_home_spread.odds: best_home_spread = outcome_obj
                    elif outcome_obj.outcome_name == fixture.away_team.name:
                        if best_away_spread is None or outcome_obj.odds > best_away_spread.odds: best_away_spread = outcome_obj
                
                if best_home_spread:
                    home_spread_point_str = f"{best_home_spread.point_value:.1f}" if best_home_spread.point_value is not None else ""
                    compact_odds_parts.append(f"üìä S {fixture.home_team.name}({home_spread_point_str}):*{best_home_spread.odds:.2f}*")
                if best_away_spread:
                    away_spread_point_str = f"({best_away_spread.point_value:.1f})" if best_away_spread.point_value is not None else ""
                    compact_odds_parts.append(f"üìä S {fixture.away_team.name}{away_spread_point_str}:*{best_away_spread.odds:.2f}*")
            
            if compact_odds_parts:
                line += "\nOdds: " + " | ".join(compact_odds_parts)
            else:
                line += "\n_No odds available_"
            individual_item_strings.append(line.strip())

    elif data_type == "finished_results":
        data_type_label = "Recent Results"
        main_header = "‚öΩ *Recent Results*"
        end_date = now
        start_date = now - timedelta(days=days_past)
        
        logger.debug(f"Querying for FINISHED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.FINISHED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').order_by('-match_date')
        
        if league_code:
            logger.debug(f"Filtering finished results by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)
        
        # ---MODIFIED BEHAVIOR---
        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria. Returning None.")
            return None
        
        num_fixtures_to_display = 10
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_fixtures_to_display)} finished matches.")
        
        for fixture in fixtures_qs[:num_fixtures_to_display]:
            match_time_local = timezone.localtime(fixture.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p')
            
            line = f"\nüèÜ *{fixture.league.name}* (ID: {fixture.id})"
            line += f"\nüóìÔ∏è {time_str}"
            line += f"\n{fixture.home_team.name} vs {fixture.away_team.name}"
            
            if fixture.home_team_score is not None:
                line += f" | Result: *{fixture.home_team_score} - {fixture.away_team_score}*"
            
            individual_item_strings.append(line.strip())

    else:
        logger.warning(f"Invalid data type requested: '{data_type}'. Returning None.")
        return None

    if not individual_item_strings:
        logger.info(f"No items to format for {data_type_label}. Returning None.")
        return None

    # Assemble message parts
    all_message_parts: List[str] = []
    current_part_items: List[str] = []
    current_part_length = 0
    header_allowance = len(main_header) + len("\n\n")

    for i, item_str in enumerate(individual_item_strings):
        separator_len = len(PART_JOINER) if current_part_items else 0
        prospective_item_len = separator_len + len(item_str)
        current_total_prospective_len = current_part_length + prospective_item_len

        if not all_message_parts:
            current_total_prospective_len += header_allowance

        if current_total_prospective_len > MAX_CHARS_PER_PART and current_part_items:
            part_to_add = PART_JOINER.join(current_part_items)
            if not all_message_parts:
                part_to_add = main_header + "\n\n" + part_to_add
            all_message_parts.append(part_to_add)
            
            current_part_items = [item_str]
            current_part_length = len(item_str)
        else:
            current_part_items.append(item_str)
            current_part_length += prospective_item_len

    if current_part_items:
        final_part_str = PART_JOINER.join(current_part_items)
        if not all_message_parts:
            final_part_str = main_header + "\n\n" + final_part_str
        all_message_parts.append(final_part_str)

    if all_message_parts:
        if len(all_message_parts[-1]) + len(footer_string) <= MAX_CHARS_PER_PART:
            all_message_parts[-1] += footer_string
        else:
            all_message_parts.append(footer_string)
    
    logger.info(f"Formatted data for data_type='{data_type}' into {len(all_message_parts)} parts.")
    return all_message_parts


def parse_betting_string(betting_string: str) -> dict:
    """
    Parses a free-form betting string into a list of market outcome IDs and a stake,
    where each bet line specifies a fixture ID (Django's auto-incrementing PK) and an outcome option.
    """
    lines = [line.strip() for line in betting_string.split('\n') if line.strip()]
    market_outcome_ids = []
    stake_amount = Decimal('0.0')

    stake_pattern = re.compile(r"Stake\s*\$?\s*([\d\.,]+)", re.IGNORECASE)
    bet_line_pattern = re.compile(r"(\d+)\s+(.*)", re.IGNORECASE)

    for line in lines:
        stake_match = stake_pattern.match(line)
        if stake_match:
            try:
                stake_str = stake_match.group(1).replace(',', '')
                stake_amount = Decimal(stake_str)
            except ValueError:
                return {"success": False, "message": f"Invalid stake amount: {stake_match.group(1)}"}
            continue

        bet_line_match = bet_line_pattern.match(line)
        if bet_line_match:
            fixture_id_str = bet_line_match.group(1).strip()
            option_text = bet_line_match.group(2).strip()

            try:
                matched_fixture = None
                try:
                    matched_fixture = FootballFixture.objects.get(id=int(fixture_id_str))
                except (ValueError, FootballFixture.DoesNotExist):
                    pass

                if not matched_fixture:
                    return {"success": False, "message": f"Could not find a fixture for ID '{fixture_id_str}'."}

                found_outcome = None
                
                outcomes_for_fixture = MarketOutcome.objects.filter(
                    market__fixture_display=matched_fixture,
                    is_active=True
                ).select_related('market')

                # Try exact outcome_name match first
                for outcome in outcomes_for_fixture:
                    if outcome.outcome_name.lower() == option_text.lower():
                        found_outcome = outcome
                        break
                
                if not found_outcome:
                    # More specific matching logic can be added here based on expected option_text formats
                    pass # Placeholder for more complex matching logic if needed

                if found_outcome:
                    market_outcome_ids.append(str(found_outcome.uuid))
                else:
                    return {"success": False, "message": f"Could not find a valid betting option for '{option_text}' in fixture '{matched_fixture.home_team.name} vs {matched_fixture.away_team.name}' (ID: {matched_fixture.id})."}

            except Exception as e:
                import traceback
                traceback.print_exc()
                return {"success": False, "message": f"Error during bet option lookup for '{fixture_id_str} {option_text}': {str(e)}"}
        else:
            return {"success": False, "message": f"Unrecognized betting line format: '{line}'"}

    if not market_outcome_ids:
        return {"success": False, "message": "No valid betting options found in the message."}
    if stake_amount <= 0:
        return {"success": False, "message": "Stake amount not found or is invalid. Please specify 'Stake $AMOUNT'."}

    return {
        "success": True,
        "market_outcome_ids": market_outcome_ids,
        "stake": float(stake_amount),
        "message": "Betting string parsed successfully."
    }
