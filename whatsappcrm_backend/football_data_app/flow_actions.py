import logging
from typing import Optional, Dict, List
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal 

from .models import FootballFixture, MarketOutcome, Market, League

logger = logging.getLogger(__name__)

def get_formatted_football_data(
    data_type: str, 
    league_code: Optional[str] = None, 
    days_ahead: int = 10, 
    days_past: int = 2
) -> str:
    """
    Fetches and formats football data for display in a single, attractive message.
    Output is highly condensed: League, Match ID, Teams, and simplified odds/results.
    Includes emojis and a "Generated by BetBlitz" footer with date/time.
    """
    logger.info(f"Function Call: get_formatted_football_data(data_type='{data_type}', league_code='{league_code}', days_ahead={days_ahead}, days_past={days_past})")

    now = timezone.now()
    message_lines: List[str] = []
    
    if data_type == "scheduled_fixtures":
        data_type_label = "Upcoming Matches"
        main_header = f"âš½ *{data_type_label}*"
        start_date = now
        end_date = now + timedelta(days=days_ahead)
        
        logger.debug(f"Querying for SCHEDULED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.SCHEDULED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').prefetch_related(
            'markets__outcomes'
        ).order_by('match_date')

        if league_code:
            logger.debug(f"Filtering scheduled fixtures by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)

        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            return f"No {data_type_label.lower()} found{league_info} at this time."

        message_lines.append(main_header)
        
        # --- Adjusted limit for more space for emojis and footer ---
        num_matches_to_display = 5 # Displaying up to 5 matches for conciseness
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_matches_to_display)} scheduled matches.")

        for match in fixtures_qs[:num_matches_to_display]: 
            # Compact line output for scheduled matches with emojis
            line = f"\nðŸ† *{match.league.name}* (ID: {match.id})" # League and Match ID on one line
            line += f"\n{match.home_team.name} vs {match.away_team.name}"
            
            # --- Aggregate and select best odds for display (one per odd type) ---
            aggregated_outcomes: Dict[str, Dict[str, MarketOutcome]] = {} 
            
            for market in match.markets.all():
                market_key = market.api_market_key
                if market_key not in aggregated_outcomes:
                    aggregated_outcomes[market_key] = {}

                for outcome in market.outcomes.all():
                    outcome_identifier = f"{outcome.outcome_name}-{outcome.point_value if outcome.point_value is not None else ''}"
                    current_best_outcome = aggregated_outcomes[market_key].get(outcome_identifier)
                    if current_best_outcome is None or outcome.odds > current_best_outcome.odds:
                        aggregated_outcomes[market_key][outcome_identifier] = outcome
            
            # --- Prepare compact odds line with emojis ---
            compact_odds_parts: List[str] = []

            # H2H (Moneyline) - ðŸ H:Odds | ðŸ¤D:Odds | âœˆï¸A:Odds
            if 'h2h' in aggregated_outcomes:
                home_odds = aggregated_outcomes['h2h'].get(f"{match.home_team.name}-")
                draw_odds = aggregated_outcomes['h2h'].get('Draw-')
                away_odds = aggregated_outcomes['h2h'].get(f"{match.away_team.name}-")
                
                if home_odds: compact_odds_parts.append(f"ðŸ H:*{home_odds.odds:.2f}*") 
                if draw_odds: compact_odds_parts.append(f"ðŸ¤D:*{draw_odds.odds:.2f}*")
                if away_odds: compact_odds_parts.append(f"âœˆï¸A:*{away_odds.odds:.2f}*")

            # Totals (Over/Under) - â¬†ï¸O#.##:Odds | â¬‡ï¸U#.##:Odds
            if 'totals' in aggregated_outcomes:
                best_overall_over = None; best_overall_under = None
                for outcome_obj in aggregated_outcomes['totals'].values():
                    if 'over' in outcome_obj.outcome_name.lower():
                        if best_overall_over is None or outcome_obj.odds > best_overall_over.odds: best_overall_over = outcome_obj
                    elif 'under' in outcome_obj.outcome_name.lower():
                        if best_overall_under is None or outcome_obj.odds > best_overall_under.odds: best_overall_under = outcome_obj
                
                if best_overall_over: compact_odds_parts.append(f"â¬†ï¸O{best_overall_over.point_value if best_overall_over.point_value is not None else ''}:*{best_overall_over.odds:.2f}*")
                if best_overall_under: compact_odds_parts.append(f"â¬‡ï¸U{best_overall_under.point_value if best_overall_under.point_value is not None else ''}:*{best_overall_under.odds:.2f}*")

            # BTTS (Both Teams To Score) - âœ…BTTS Y:Odds | âŒBTTS N:Odds
            if 'btts' in aggregated_outcomes:
                yes_odds = aggregated_outcomes['btts'].get('Yes-') 
                no_odds = aggregated_outcomes['btts'].get('No-')   
                if yes_odds: compact_odds_parts.append(f"âœ…BTTS Y:*{yes_odds.odds:.2f}*")
                if no_odds: compact_odds_parts.append(f"âŒBTTS N:*{no_odds.odds:.2f}*")
            
            # Spreads (Handicap) - ðŸ“Š S Team(X.X):Odds
            if 'spreads' in aggregated_outcomes:
                best_home_spread = None; best_away_spread = None
                for outcome_obj in aggregated_outcomes['spreads'].values():
                    if outcome_obj.outcome_name == match.home_team.name:
                        if best_home_spread is None or outcome_obj.odds > best_home_spread.odds: best_home_spread = outcome_obj
                    elif outcome_obj.outcome_name == match.away_team.name:
                        if best_away_spread is None or outcome_obj.odds > best_away_spread.odds: best_away_spread = outcome_obj
                
                if best_home_spread: compact_odds_parts.append(f"ðŸ“Š S {match.home_team.name}({best_home_spread.point_value}):*{best_home_spread.odds:.2f}*")
                if best_away_spread: compact_odds_parts.append(f"ðŸ“Š S {match.away_team.name}({best_away_spread.point_value}):*{best_away_spread.odds:.2f}*")
            
            # Final odds line for this match
            if compact_odds_parts:
                line += "\nOdds: " + " | ".join(compact_odds_parts)
            else:
                line += "\n_No odds available_" # Compact message if no odds
            
            message_lines.append(line)
        
    elif data_type == "finished_results":
        main_header = "âš½ *Recent Results*"
        data_type_label = "Recent Results" # For log messages
        end_date = now
        start_date = now - timedelta(days=days_past)
        
        logger.debug(f"Querying for FINISHED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.FINISHED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').order_by('-match_date')
        
        if league_code:
            logger.debug(f"Filtering finished results by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)
        
        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            return f"No {data_type_label.lower()} found{league_info} at this time."

        message_lines.append(main_header)
        
        # --- Adjusted limit for more space for emojis and footer ---
        num_matches_to_display = 5 # Displaying up to 5 matches for conciseness
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_matches_to_display)} finished matches.")
        for match in fixtures_qs[:num_matches_to_display]: 
            # Compact line output for finished results with emojis
            line = f"\nðŸ† *{match.league.name}* (ID: {match.id})" # League and Match ID
            line += f"\n{match.home_team.name} vs {match.away_team.name}"
            
            if match.home_team_score is not None:
                line += f" | Result: *{match.home_team_score} - {match.away_team_score}*" # Compact result
            
            message_lines.append(line)

    else:
        logger.warning(f"Invalid data type requested: '{data_type}'. Returning error message.")
        return "Invalid data type requested. Please check your input."

    # Final assembly of the message with separator and footer
    # Join with a separator to create a single string message
    final_message = "\n\n---\n".join(message_lines) 
    
    # --- Add the "Generated by BetBlitz" footer ---
    now_harare = timezone.localtime(timezone.now()) # Assumes TIME_ZONE in settings is 'Africa/Harare' or similar
    datetime_str = now_harare.strftime('%B %d, %Y, %I:%M %p %Z') # e.g., June 12, 2025, 10:24 PM CAT
    final_message += f"\n\n_Generated by BetBlitz on {datetime_str}_"

    logger.info(f"Successfully formatted data for data_type='{data_type}'. Generated message length: {len(final_message)} characters.")

    # Final check: if the message is still too long, return an error.
    # This is a last resort, as the match limit should generally prevent this.
    if len(final_message) > 4096:
        logger.error(f"Generated message for {data_type} exceeds 4096 characters ({len(final_message)}). This should not happen with current limits. Returning truncated message.")
        return final_message[:4090] + "..." # Truncate and add ellipsis

    return final_message