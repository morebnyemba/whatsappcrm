import logging
from typing import Optional, Dict, List
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal 

from .models import FootballFixture, MarketOutcome, Market, League

logger = logging.getLogger(__name__)

def get_formatted_football_data(
    data_type: str, 
    league_code: Optional[str] = None, 
    days_ahead: int = 10, 
    days_past: int = 2
) -> str: # Return type remains str for single message output
    """
    Fetches and formats football data for display in a single, attractive message.
    Output includes: League, Match ID, Date/Time, Teams, and simplified odds/results.
    Displays up to 10 matches. Includes emojis and a "Generated by BetBlitz" footer.
    WARNING: This configuration might exceed WhatsApp's 4096 character limit for a single message.
    """
    logger.info(f"Function Call: get_formatted_football_data(data_type='{data_type}', league_code='{league_code}', days_ahead={days_ahead}, days_past={days_past})")

    now = timezone.now()
    message_lines: List[str] = [] 
    
    if data_type == "scheduled_fixtures":
        data_type_label = "Upcoming Matches"
        main_header = f"⚽ *{data_type_label}*"
        start_date = now
        end_date = now + timedelta(days=days_ahead)
        
        logger.debug(f"Querying for SCHEDULED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.SCHEDULED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').prefetch_related(
            'markets__outcomes'
        ).order_by('match_date')

        if league_code:
            logger.debug(f"Filtering scheduled fixtures by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)

        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            return f"No {data_type_label.lower()} found{league_info} at this time."

        message_lines.append(main_header)
        
        num_matches_to_display = 10 
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_matches_to_display)} scheduled matches.")

        for match in fixtures_qs[:num_matches_to_display]: 
            match_time_local = timezone.localtime(match.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p') 
            
            line = f"\n🏆 *{match.league.name}* (ID: {match.id})" 
            line += f"\n🗓️ {time_str}" 
            line += f"\n{match.home_team.name} vs {match.away_team.name}"
            
            aggregated_outcomes: Dict[str, Dict[str, MarketOutcome]] = {} 
            
            for market in match.markets.all():
                market_key = market.api_market_key
                if market_key not in aggregated_outcomes:
                    aggregated_outcomes[market_key] = {}

                for outcome in market.outcomes.all():
                    outcome_identifier = f"{outcome.outcome_name}-{outcome.point_value if outcome.point_value is not None else ''}"
                    current_best_outcome = aggregated_outcomes[market_key].get(outcome_identifier)
                    if current_best_outcome is None or outcome.odds > current_best_outcome.odds:
                        aggregated_outcomes[market_key][outcome_identifier] = outcome
            
            compact_odds_parts: List[str] = []

            if 'h2h' in aggregated_outcomes:
                home_odds = aggregated_outcomes['h2h'].get(f"{match.home_team.name}-")
                draw_odds = aggregated_outcomes['h2h'].get('Draw-')
                away_odds = aggregated_outcomes['h2h'].get(f"{match.away_team.name}-")
                
                if home_odds: compact_odds_parts.append(f"🏠H:*{home_odds.odds:.2f}*") 
                if draw_odds: compact_odds_parts.append(f"🤝D:*{draw_odds.odds:.2f}*")
                if away_odds: compact_odds_parts.append(f"✈️A:*{away_odds.odds:.2f}*")

            if 'totals' in aggregated_outcomes:
                best_overall_over = None; best_overall_under = None
                for outcome_obj in aggregated_outcomes['totals'].values():
                    if 'over' in outcome_obj.outcome_name.lower():
                        if best_overall_over is None or outcome_obj.odds > best_overall_over.odds: best_overall_over = outcome_obj
                    elif 'under' in outcome_obj.outcome_name.lower():
                        if best_overall_under is None or outcome_obj.odds > best_overall_under.odds: best_overall_under = outcome_obj
                
                if best_overall_over: compact_odds_parts.append(f"⬆️O{best_overall_over.point_value if best_overall_over.point_value is not None else '':.1f}:*{best_overall_over.odds:.2f}*") 
                if best_overall_under: compact_odds_parts.append(f"⬇️U{best_overall_under.point_value if best_overall_under.point_value is not None else '':.1f}:*{best_overall_under.odds:.2f}*")

            if 'btts' in aggregated_outcomes:
                yes_odds = aggregated_outcomes['btts'].get('Yes-') 
                no_odds = aggregated_outcomes['btts'].get('No-')   
                if yes_odds: compact_odds_parts.append(f"✅BTTS Y:*{yes_odds.odds:.2f}*")
                if no_odds: compact_odds_parts.append(f"❌BTTS N:*{no_odds.odds:.2f}*")
            
            if 'spreads' in aggregated_outcomes:
                best_home_spread = None; best_away_spread = None
                for outcome_obj in aggregated_outcomes['spreads'].values():
                    if outcome_obj.outcome_name == match.home_team.name:
                        if best_home_spread is None or outcome_obj.odds > best_home_spread.odds: best_home_spread = outcome_obj
                    elif outcome_obj.outcome_name == match.away_team.name:
                        if best_away_spread is None or outcome_obj.odds > best_away_spread.odds: best_away_spread = outcome_obj
                
                if best_home_spread: compact_odds_parts.append(f"📊 S {match.home_team.name}({best_home_spread.point_value if best_home_spread.point_value is not None else '':.1f}):*{best_home_spread.odds:.2f}*") 
                if best_away_spread: compact_odds_parts.append(f"📊 S {match.away_team.name}({best_away_spread.point_value if best_away_spread.point_value is not None else '':.1f}):*{best_away_spread.odds:.2f}*") 
            
            if compact_odds_parts:
                line += "\nOdds: " + " | ".join(compact_odds_parts)
            else:
                line += "\n_No odds available_" 
            
            message_lines.append(line)
        
    elif data_type == "finished_results":
        data_type_label = "Recent Results"
        main_header = "⚽ *Recent Results*"
        end_date = now
        start_date = now - timedelta(days=days_past)
        
        logger.debug(f"Querying for FINISHED fixtures between {start_date} and {end_date}.")
        fixtures_qs = FootballFixture.objects.filter(
            status=FootballFixture.FixtureStatus.FINISHED,
            match_date__gte=start_date,
            match_date__lte=end_date
        ).select_related('home_team', 'away_team', 'league').order_by('-match_date')
        
        if league_code:
            logger.debug(f"Filtering finished results by league_code: {league_code}.")
            fixtures_qs = fixtures_qs.filter(league__api_id=league_code)
        
        if not fixtures_qs.exists():
            league_info = f" in {league_code}" if league_code else ""
            logger.info(f"No {data_type_label.lower()} found{league_info} for the specified criteria.")
            return f"No {data_type_label.lower()} found{league_info} at this time."

        message_lines.append(main_header)
        
        num_matches_to_display = 10 
        logger.debug(f"Formatting details for up to {min(fixtures_qs.count(), num_matches_to_display)} finished matches.")
        for match in fixtures_qs[:num_matches_to_display]: 
            match_time_local = timezone.localtime(match.match_date)
            time_str = match_time_local.strftime('%a, %b %d - %I:%M %p') 
            
            line = f"\n🏆 *{match.league.name}* (ID: {match.id})" 
            line += f"\n🗓️ {time_str}" 
            line += f"\n{match.home_team.name} vs {match.away_team.name}"
            
            if match.home_team_score is not None:
                line += f" | Result: *{match.home_team_score} - {match.away_team_score}*" 
            
            message_lines.append(line)

    else:
        logger.warning(f"Invalid data type requested: '{data_type}'. Returning error message.")
        return "Invalid data type requested. Please check your input."

    # Final assembly of the message with separator and footer
    final_message = "\n\n---\n".join(message_lines) 
    
    # --- Add the "Generated by BetBlitz" footer ---
    now_harare = timezone.localtime(timezone.now()) 
    datetime_str = now_harare.strftime('%B %d, %Y, %I:%M %p %Z') 
    final_message += f"\n\n_Generated by BetBlitz on {datetime_str}_"

    logger.info(f"Successfully formatted data for data_type='{data_type}'. Generated message length: {len(final_message)} characters.")

    # --- FINAL SAFETY CHECK TO ENSURE NON-EMPTY BODY ---
    if not final_message.strip(): # Check if it's empty or just whitespace
        logger.error(f"Generated message for {data_type} is empty or contains only whitespace. Returning a fallback message.")
        return "Sorry, I couldn't find or format any football data right now. Please try again later."

    # Final check for length, as this is a single message approach
    if len(final_message) > 4096:
        logger.error(f"Generated message for {data_type} exceeds 4096 characters ({len(final_message)}). This will likely cause a WhatsApp API error. Returning truncated message.")
        return final_message[:4090] + "..." 

    return final_message